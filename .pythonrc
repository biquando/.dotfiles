import numpy as np
import math
from math import *
import sympy
from sympy import *
from functools import reduce
import os

import matplotlib
import matplotlib.pyplot as plt
plt.ion()
os.environ['MPLBACKEND_KITTY_SIZING'] = 'manual'
try:
    matplotlib.use('module://matplotlib-backend-kitty')
except ModuleNotFoundError as _:
    pass

R = radians
D = degrees

def sci(x, prec=2):
    """Print a number in scientific notation

    Args:
        x (number): the number to print
        prec (int): number of digits after the decimal
    """
    print((f'{{:.{prec}e}}').format(x))

def integrate(f, a, b, dx=0.0001):
    """Numerically integrate a function

    Args:
        f (function): function to integrate
        a (float): lower bound
        b (float): upper bound
        dx (float): width of each sample

    Returns:
        integral from a to b of f(x)dx
    """
    fn = np.vectorize(f)
    if a > b:
        c = a
        a = b
        b = c
        fn = np.vectorize(lambda x: -1 * f(x))
    x = np.linspace(a+dx, b-dx, int((b-a)/dx))
    return np.sum(fn(x)*dx)

def summation(f, a, b):
    """Calculate the summation of a discrete function

    Args:
        f (function): function to sum
        a (int): lower bound (inclusive)
        b (int): upper bound (inclusive)

    Returns:
        sum of f(x) for x from a to b
    """
    x = np.linspace(a, b, b-a+1, dtype=int)
    fn = np.vectorize(f)
    return np.sum(fn(x))

fac = lambda x: factorial(x) if isinstance(x, int) else gamma(x+1)
C = lambda n, r: factorial(n) / factorial(n-r) / factorial(r)
binom_dist = lambda n, p: lambda k: C(n, k) * p**k * (1-p)**(n-k)
poisson_dist = lambda l: lambda k: l**k * exp(-l) / fac(k)
exp_dist = lambda l: lambda x: l*exp(-l*x)
gamma_dist = lambda a, l: lambda x: l*exp(-l*x)*(l*x)**(a-1)/gamma(a)
lognormal_dist = lambda u, s: lambda y: \
    1/(y*s*sqrt(2*pi))*exp(-((log(y)-u)**2)/(2*s**2))
gaussian_dist = lambda u=0, s=1: lambda x: \
    1/(s*sqrt(2*pi))*exp(-1/2*((x-u)/s)**2)
normal_dist = gaussian_dist

def plot_discrete(f, a, b):
    x = np.array(range(a, b+1))
    y = np.vectorize(f)(x)
    plt.scatter(x, y)
    plt.show()

def plot_continuous(f, a, b, dx=0.0001):
    x = np.linspace(a+dx, b-dx, int((b-a)/dx))
    y = np.vectorize(f)(x)
    plt.plot(x, y)
    plt.show()

# === Physics ==================================================================

g = 9.81
u0 = 4*pi*10**-7
e0 = 8.8541878188e-12
c = 299792458
h = 6.62607015e-34
hbar = h / (2 * pi)
eV = 1.602176634e-19
m_e = 9.1093837139e-31
m_p = 1.67262192595e-27
m_n = 1.67492750056e-27
k_b = 1.380649e-23
k_e = 1/(4*pi*e0)
N_A = 6.02214076e23
atm = 101325
sigma = 5.670374419e-8
G = 6.67430e-11

# Calculates the Lorentz factor
#   u:  speed of the reference frame
def lorentz(u):
    return 1 / sqrt(1 - (u/c)**2)

# Calculates the speed of a reference frame
#   gamma:  the Lorentz factor
def lorentz_(gamma):
    return c * sqrt(1 - (1/gamma)**2)
